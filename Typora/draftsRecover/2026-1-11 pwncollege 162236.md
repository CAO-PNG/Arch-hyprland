# After text

这个是我正式开始的kernel pwn练习题，地址：[pwncollege](https://pwn.college/system-security/kernel-security/)

首先简单的说明一下怎么从pwncollege上下载`ko`模块文件，我们需要切换成将左下角的`Terminal`切换成`Code`，然后打开文件夹`/challege/`这里就是我们的模块文件所在的地方了，我们只需要右键Download下来即可

# level1.0&&leave1.1

使用ida打开，首先查看`init_module`

```c
int __cdecl init_module()
{
  __int64 v0; // rbp

  v0 = filp_open("/flag", 0, 0);
  memset(flag, 0, sizeof(flag));
  kernel_read(v0, flag, 128, v0 + 104);
  filp_close(v0, 0);
  proc_entry = (proc_dir_entry *)proc_create("pwncollege", 438, 0, &fops);
  printk(&unk_8E1);
  printk(&unk_6E0);
  printk(&unk_8E1);
  printk(&unk_710);
  printk(&unk_778);
  printk(&unk_7D8);
  printk(&unk_828);
  printk(&unk_8E8);
  return 0;
}
```

可以看到是打开`/flag`这个文件，然后将读入`v0`这个变量，使用`proc_create`创建一个`pwncollege`文件来交互，双击`&fops`查看交互接口是`device_write`

```assembly
.data:0000000000000AA0 fops            file_operations <0, 0, offset device_read, offset device_write, 0, 0, \
.data:0000000000000AA0                                         ; DATA XREF: init_module+4A↑o
.data:0000000000000AA0                                  0, 0, 0, 0, 0, 0, 0, 0, offset device_open, 0, \
.data:0000000000000AA0                                  offset device_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
.data:0000000000000AA0                                  0, 0, 0, 0, 0>
```

所以，当我们向`/proc/pwncollege`这个文件写入的时候，就会调用‘device_write’这个函数，

```c
ssize_t __fastcall device_write(file *file, const char *buffer, size_t length, loff_t *offset)
{
  size_t v5; // rdx
  char password[16]; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v8; // [rsp+10h] [rbp-18h]

  v8 = __readgsqword(0x28u);
  printk(&unk_660);
  v5 = 16;
  if ( length <= 0x10 )
    v5 = length;
  copy_from_user(password, buffer, v5);
  device_state[0] = (strncmp(password, "gyvcbzlksuywlujh", 0x10u) == 0) + 1;
  return length;
}
```

在这里可以看到一个很明显的密码判断。只需要我们输入 一致，就会使得`device_state[0]`为2，而当我们使device_state[0]为2之后再次执行`cat /proc/college`就会去执行device_read从而把flag打印出来

```c
ssize_t __fastcall device_read(file *file, char *buffer, size_t length, loff_t *offset)
{
  const char *v6; // rsi
  size_t v7; // rdx
  unsigned __int64 v8; // rax

  printk(&unk_6A0);
  v6 = flag;
  if ( device_state[0] != 2 )
  {
    v6 = "device error: unknown state\n";
    if ( device_state[0] <= 2 )
    {
      v6 = "password:\n";
      if ( device_state[0] )
      {
        v6 = "device error: unknown state\n";
        if ( device_state[0] == 1 )
        {
          device_state[0] = 0;
          v6 = "invalid password\n";
        }
      }
    }
  }
  v7 = length;
  v8 = strlen(v6) + 1;
  if ( v8 - 1 <= length )
    v7 = v8 - 1;
  return v8 - 1 - copy_to_user(buffer, v6, v7);
}
```

所以，我们只需要输入正确的密码，然后‘cat /proc/pwncollege’就可以得到flag

**exp**

在远程vm环境运行即可拿到flag

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define get_Flag_Path  "/proc/pwncollege"

int main (){
        char * Passwd = "gyvcbzlksuywlujh";
        int fd = open(get_Flag_Path,O_WRONLY);
       if (fd<0){
      	printf("OPEN ERROR check you File !!!\n And you fd is %d\n",fd);
       }
      if (write(fd,Passwd,strlen(Passwd))>0){
          printf("Fd is %d,You Are Win",fd);
      }
        close(fd);
        return EXIT_SUCCESS;
}
```

leave1.1也是一样的解法

# leave2.0&&leave2.1

先看程序一样的：

```c
int __cdecl init_module()
{
  __int64 v0; // rbp

  v0 = filp_open("/flag", 0, 0);
  memset(flag, 0, sizeof(flag));
  kernel_read(v0, flag, 128, v0 + 104);
  filp_close(v0, 0);
  proc_entry = (proc_dir_entry *)proc_create("pwncollege", 438, 0, &fops);
  printk(&unk_79C);
  printk(&unk_5D8);
  printk(&unk_79C);
  printk(&unk_608);
  printk(&unk_670);
  printk(&unk_6D0);
  printk(&unk_718);
  printk(&unk_7A3);
  return 0;
}
.data:0000000000000920 fops            file_operations <0, 0, 0, offset device_write, 0, 0, 0, 0, 0, 0, 0, 0,\
.data:0000000000000920                                         ; DATA XREF: init_module+4A↑o
.data:0000000000000920                                  0, 0, offset device_open, 0, offset device_release, \
.data:0000000000000920                                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>
.data:0000000000000920 _data           ends
```

可以看到会调用device_write.那么接下来查看device_write

```c
ssize_t __fastcall device_write(file *file, const char *buffer, size_t length, loff_t *offset)
{
  size_t v5; // rdx
  char password[16]; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v8; // [rsp+10h] [rbp-18h]

  v8 = __readgsqword(0x28u);
  printk(&unk_598);
  v5 = 16;
  if ( length <= 0x10 )
    v5 = length;
  copy_from_user(password, buffer, v5);
  if ( !strncmp(password, "kfjplhjtylqmntng", 0x10u) )
    printk(&format); //printk == printf 不过是打印在日志里面
  return length;
}
```

这里ida出现了问题，没有把2参放出来，查看汇编如下

```assembly
.rodata.str1.1:0000000000000778 format          db    1                 ; DATA XREF: device_write+6C↑o
.rodata.str1.1:0000000000000779                 db  36h ; 6
.rodata.str1.1:000000000000077A                 db  54h ; T
.rodata.str1.1:000000000000077B                 db  68h ; h
.rodata.str1.1:000000000000077C                 db  65h ; e
.rodata.str1.1:000000000000077D                 db  20h
.rodata.str1.1:000000000000077E                 db  66h ; f
.rodata.str1.1:000000000000077F                 db  6Ch ; l
.rodata.str1.1:0000000000000780                 db  61h ; a
.rodata.str1.1:0000000000000781                 db  67h ; g
.rodata.str1.1:0000000000000782                 db  20h
.rodata.str1.1:0000000000000783                 db  69h ; i
.rodata.str1.1:0000000000000784                 db  73h ; s
.rodata.str1.1:0000000000000785                 db  3Ah ; :
.rodata.str1.1:0000000000000786                 db  20h
.rodata.str1.1:0000000000000787                 db  25h ; %
.rodata.str1.1:0000000000000788                 db  73h ; s
.rodata.str1.1:0000000000000789                 db  0Ah

================================================================================================================
.text.unlikely:0000000000000511                 mov     rsi, offset flag
.text.unlikely:0000000000000518                 mov     rdi, offset format ; 可以看到，会把flag当成二参打印出来
.text.unlikely:000000000000051F                 call    printk          ; PIC mode
```

exp

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define get_Flag_Path  "/proc/pwncollege"

int main (){
        char * Passwd = "kfjplhjtylqmntng";
        int fd = open(get_Flag_Path,O_WRONLY);
       if (fd<0){
      	printf("OPEN ERROR check you File !!!\n And you fd is %d\n",fd);
       }
      if (write(fd,Passwd,strlen(Passwd))>0){
          printf("Fd is %d,You Are Win",fd);
      }
        close(fd);
        return EXIT_SUCCESS;
}
// 最后dmesg | tail -n 20,可以看到flag
```

# leave3.0&&leave3.1

分析代码：

```c
int __cdecl init_module()
{
  proc_entry = (proc_dir_entry *)proc_create("pwncollege", 438, 0, &fops);
  printk(&unk_1041);
  printk(&unk_E78);
  printk(&unk_1041);
  printk(&unk_EA8);
  printk(&unk_F10);
  printk(&unk_F70);
  printk(&unk_FB8);
  printk(&unk_1048);
  return 0;
}
.data:00000000000011A0 fops            file_operations <0, 0, 0, offset device_write, 0, 0, 0, 0, 0, 0, 0, 0,\
.data:00000000000011A0                                         ; DATA XREF: init_module↑o
.data:00000000000011A0                                  0, 0, offset device_open, 0, offset device_release, \
.data:00000000000011A0                                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>
```

```c
ssize_t __fastcall device_write(file *file, const char *buffer, size_t length, loff_t *offset)
{
  size_t v5; // rdx
  char password[16]; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v8; // [rsp+10h] [rbp-18h]

  v8 = __readgsqword(0x28u);
  printk(&unk_E38);
  v5 = 16;
  if ( length <= 0x10 )
    v5 = length;
  copy_from_user(password, buffer, v5);
  if ( !strncmp(password, "sfvzlmiqphywsyfk", 0x10u) )
    win();
  return length;
}
```

```c
void __cdecl win()
{
  __int64 v0; // rax

  printk(&unk_DF8);
  v0 = prepare_kernel_cred(0); 
  commit_creds(v0);			//值得注意的 是这两行代码 会提权，提升至root权限
}
```

所以其实很简单了，

我们只要输入密码，就会正常的进入win,使得我们的权限提升至root,从而可以拿到flag

exp

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define get_Flag_Path  "/proc/pwncollege"

int main (){
        char * Passwd = "sfvzlmiqphywsyfk";
        int fd = open(get_Flag_Path,O_WRONLY);
       if (fd<0){
      	printf("OPEN ERROR check you File !!!\n And you fd is %d\n",fd);
       }
      if (write(fd,Passwd,strlen(Passwd))>0){
          printf("Fd is %d,You Are Win",fd);
      }
   	   system("cat /flag");
        close(fd);
        return EXIT_SUCCESS;
}
```

leave3.1同理

# leave4.0&&leave4.1

```c
int __cdecl init_module()
{
  proc_entry = (proc_dir_entry *)proc_create("pwncollege", 438, 0, &fops);
  printk(&unk_531);
  printk(&unk_328);
  printk(&unk_531);
  printk(&unk_358);
  printk(&unk_3C0);
  printk(&unk_420);
  printk(&unk_460);
  printk(&unk_4A8);
  printk(&unk_538);
  return 0;
}
```



```assembly
0000680 fops            file_operations <0, 0, 0, 0, 0, 0, 0, 0, 0, 0, offset device_ioctl, 0,\
.data:0000000000000680                                         ; DATA XREF: init_module↑o
.data:0000000000000680                                  0, 0, offset device_open, 0, offset device_release, \
.data:0000000000000680                                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>
```

可以看到会调用device_ioctl，

```c
__int64 __fastcall device_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)
{
  __int64 result; // rax
  int v5; // r8d
  char password[16]; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v7; // [rsp+10h] [rbp-18h]

  v7 = __readgsqword(0x28u);
  printk(&unk_2F8);
  result = -1;
  if ( cmd == 1337 )
  {
    copy_from_user(password, arg, 16);
    v5 = strncmp(password, "czmepuekljhzwqou", 0x10u);
    result = 0;
    if ( !v5 )
    {
      win();
      return 0;
    }
  }
  return result;
}
```

简单介绍一下ioctl函数

`ioctl` 是一个专用于设备输入输出操作的一个系统调用，其调用方式如下：

```c
int ioctl(int fd, unsigned long request, ...)
```

其**第一个参数为打开设备 (open) 返回的 [文件描述符](http://m4x.fun/post/play-with-file-descriptor-1/)**，第二个参数为**用户程序对设备的控制命令**，再后边的参数则是一些补充参数，与设备有关。

对于一个提供了 ioctl 通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过 ioctl 系统调用完成不同的对设备的 I/O 操作。

而在这里要求了cmd是1337：而1337
