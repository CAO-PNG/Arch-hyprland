io是高版本的堆利用绕不过去的一关，但是网上又没有成体系的教程，所幸，遇到了gets这位大师傅，跟他的博客去学习IO,

# IO

## 什么是IO_File 

众所周知，linux把一切当作文件来处理，io file结构体是标准C库（如glibc）中的一个数据结构，**用于表示和管理文件流**。也就是控制io file这个结构体，就可以达到很多我们想要达到的效果，包括但是不仅限于调用system函数

那么这个结构体是什么样的呢？

```c
struct _IO_FILE {
    int _flags;                // 文件状态标志（高位是 _IO_MAGIC，其余是标志位）
    char* _IO_read_ptr;        // 读缓冲区当前读取位置
    char* _IO_read_end;        // 读缓冲区结束位置
    char* _IO_read_base;       // 读缓冲区基地址
    char* _IO_write_base;      // 写缓冲区基地址
    char* _IO_write_ptr;       // 写缓冲区当前写入位置
    char* _IO_write_end;       // 写缓冲区结束位置
    char* _IO_buf_base;        // 缓冲区基地址
    char* _IO_buf_end;         // 缓冲区结束位置
    char *_IO_save_base;       // 保存缓冲区基地址
    char *_IO_backup_base;     // 备份缓冲区基地址
    char *_IO_save_end;        // 保存缓冲区结束位置
    struct _IO_marker *_markers; // 标记指针，用于跟踪缓冲区的读写位置
    struct _IO_FILE *_chain;   // 链接到下一个文件结构，用于文件链表
    int _fileno;               // 文件描述符
    int _flags2;               // 额外的文件状态标志
    __off_t _old_offset;       // 文件偏移（旧版，已弃用）
    unsigned short _cur_column; // 当前列号（用于支持列计算）
    signed char _vtable_offset; // 虚函数表偏移量
    char _shortbuf[1];         // 短缓冲区（用于小量数据的快速操作）
    _IO_lock_t *_lock;         // 文件锁（用于多线程环境下的文件流操作保护）
};
```

幸好gets大神给了注释，要不然还要我一个个找

在平时的pwn题中一般init函数里面会有setvbuf函数，用于对stdin，stdout，stderr进行初始化，

`stdin`、`stdout`和`stderr`是C语言中标准输入、标准输出和标准错误流的文件指针。它们是通过`_IO_FILE`结构体实现的，并在程序启动时由系统自动初始化

其实这几个的结构体和IO_File很相似(几乎一样)

然后我们再来看一下io_jump_t的结构

```c
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);               // 占位符，没有实际功能
    JUMP_FIELD(size_t, __dummy2);              // 占位符，没有实际功能
    JUMP_FIELD(_IO_finish_t, __finish);        // 完成操作的函数指针
    JUMP_FIELD(_IO_overflow_t, __overflow);    // 写缓冲区溢出处理函数指针
    JUMP_FIELD(_IO_underflow_t, __underflow);  // 读缓冲区欠载处理函数指针
    JUMP_FIELD(_IO_underflow_t, __uflow);      // 读缓冲区欠载处理函数指针
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);  // 处理推回字符的函数指针
    JUMP_FIELD(_IO_xsputn_t, __xsputn);        // 写入多个字符的函数指针
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);        // 读取多个字符的函数指针
    JUMP_FIELD(_IO_seekoff_t, __seekoff);      // 按偏移量移动文件指针的函数指针
    JUMP_FIELD(_IO_seekpos_t, __seekpos);      // 移动文件指针到指定位置的函数指针
    JUMP_FIELD(_IO_setbuf_t, __setbuf);        // 设置缓冲区的函数指针
    JUMP_FIELD(_IO_sync_t, __sync);            // 同步文件流的函数指针
    JUMP_FIELD(_IO_doallocate_t, __doallocate);// 分配缓冲区的函数指针
    JUMP_FIELD(_IO_read_t, __read);            // 读取数据的函数指针
    JUMP_FIELD(_IO_write_t, __write);          // 写入数据的函数指针
    JUMP_FIELD(_IO_seek_t, __seek);            // 移动文件指针的函数指针
    JUMP_FIELD(_IO_close_t, __close);          // 关闭文件流的函数指针
    JUMP_FIELD(_IO_stat_t, __stat);            // 获取文件状态的函数指针
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);  // 显示可用字符数的函数指针
    JUMP_FIELD(_IO_imbue_t, __imbue);          // 设置区域设置信息的函数指针
};
```

现在只做了解即可，这一部分涉及到了fsop，暂时不会谈及，所以你可以略过

### 小总结

好的，小总结一下，这里的结构体只要有印象就行，，然后整体的结构应该是这样的

![IO_file_plus](E:/图片/PWN/IO/IO_file_plus.png)

可以看到，这里是io_flie_plus包裹了io_file和io_jump_t ，其中io_file很chain字段在一起，chain字段中有`stdin`、`stdout`和`stderr`这三个结构体，

## 使用stdout泄露libc

stdout是什么？c语言库里面的标准输出

### 缓冲区

在理解studout泄露libc之前我们需要先理解一个东西——缓冲区，缓冲区用于临时存储数据，用于平衡衡数据生产者和数据消费者之间的速度差异，即，在输出时不会直接输出，会达到某个条件一块输出，

比如，scanf函数输入的时候，不会一个一个的放进内存中，会先在缓冲区存放，按照顺序，依次写入，那么什么时候结束呢？答案是检测到空白字符（如空格或换行符）并将遇到的空白字符留在缓冲区中,但是这种情况不是一定的，也有例外，比如%23s 无论输入多少，都只会把前23个写入缓冲区，

那么在进行一些输出函数时，应该是什么样子的？

### 输出

以puts函数为例子

首先会把输出的东西存放在缓冲区，以减少IO操作，知道结束，遇到“\n”刷新缓冲区，，**注意这里是刷新缓冲区缓冲区刷新会将缓冲区中的数据写入到实际的输出设备**（如终端）

也就是说只要刷新了缓冲区就可以将缓冲区的内容打印出来，

标准输出缓冲区有三种模式：行缓冲模式、全缓冲模式和无缓冲模式。不同的缓冲模式对 `puts` 函数的行为有不同的影响。

在行缓冲的模式下，“\n”会自动刷新一次缓冲区，数据输出，

而缓冲区的刷新具备以下几种情况：

1. **缓冲区填满**：系统会自动将缓冲区的数据写到实际输出设备，同时清空缓冲区
2. **手动刷新**：使用ddlush(FILE*stream)函数来刷新缓冲区
3. **自动退出**：当程序正常退出的时候，所有打开的文件流都会自动刷新缓冲区
4. **行缓冲模式**：通常是标准输出`stdout`在交互模式下的默认模式，这个情况下，输出新字符“\n”自动刷新缓冲区

接下来很重要的地方来了

首先回顾一下io的结构和作用(只贴了一些重要的)

```c
 char* _IO_read_ptr;        // 读缓冲区当前读取位置
    char* _IO_read_end;        // 读缓冲区结束位置
    char* _IO_read_base;       // 读缓冲区基地址
    char* _IO_write_base;      // 写缓冲区基地址
    char* _IO_write_ptr;       // 写缓冲区当前写入位置
    char* _IO_write_end;       // 写缓冲区结束位置
    char* _IO_buf_base;        // 缓冲区基地址
    char* _IO_buf_end;         // 缓冲区结束位置
    char *_IO_save_base;       // 保存缓冲区基地址
```

可以看得到，在程序开始的时候，会首先把_io_write_base的地方作为缓冲区的起始地址，然后用\_io_write_end记录缓冲区的结束地址，每写一个字节就会使ptr向后移动一个位置，,当缓冲区刷新的时候会把**base到ptr**这段空间里面的数据全部打印出来

那么现在有问题，如果我们把base修改为0x500(假设)，而ptr还是0x1000没变，那么这个时候我们刷新缓冲区就会将（0x500–0x1000）这段空间的数据都打印出来，

这就是stdout利用的点，那么怎么去修改这个结构体呢？接下来说明，在这之前需要知道一个东西，上面那个结构体的第一个参数  **flag**标志位

```c
#define _IO_MAGIC 0xFBAD0000           /* Magic number 文件结构体的魔数，用于标识文件结构体的有效性 */
#define _OLD_STDIO_MAGIC 0xFABC0000    /* Emulate old stdio 模拟旧的标准输入输出库（stdio）行为的魔数 */
#define _IO_MAGIC_MASK 0xFFFF0000      /* Magic mask 魔数掩码，用于从 _flags 变量中提取魔数部分 */
#define _IO_USER_BUF 1                 /* User owns buffer; don't delete it on close. 用户拥有缓冲区，不在关闭时删除缓冲区 */
#define _IO_UNBUFFERED 2               /* Unbuffered 无缓冲模式，直接进行I/O操作，不使用缓冲区 */
#define _IO_NO_READS 4                 /* Reading not allowed 不允许读取操作 */
#define _IO_NO_WRITES 8                /* Writing not allowed 不允许写入操作 */
#define _IO_EOF_SEEN 0x10              /* EOF seen 已经到达文件结尾（EOF） */
#define _IO_ERR_SEEN 0x20              /* Error seen 已经发生错误 */
#define _IO_DELETE_DONT_CLOSE 0x40     /* Don't call close(_fileno) on cleanup. 不关闭文件描述符 _fileno，在清理时不调用 close 函数 */
#define _IO_LINKED 0x80                /* Set if linked (using _chain) to streambuf::_list_all. 链接到一个链表（使用 _chain 指针），用于 streambuf::_list_all */
#define _IO_IN_BACKUP 0x100            /* In backup 处于备份模式 */
#define _IO_LINE_BUF 0x200             /* Line buffered 行缓冲模式，在输出新行时刷新缓冲区 */
#define _IO_TIED_PUT_GET 0x400         /* Set if put and get pointer logically tied. 在输出和输入指针逻辑上绑定时设置 */
#define _IO_CURRENTLY_PUTTING 0x800    /* Currently putting 当前正在执行 put 操作 */
#define _IO_IS_APPENDING 0x1000        /* Is appending 处于附加模式（在文件末尾追加内容） */
#define _IO_IS_FILEBUF 0x2000          /* Is file buffer 是一个文件缓冲区 */
#define _IO_BAD_SEEN 0x4000            /* Bad seen 遇到错误（bad flag set） */
#define _IO_USER_LOCK 0x8000           /* User lock 用户锁定，防止其他线程访问 */
```

这个没什么好说的，都是规定好的，你甚至可以完全不看，只需要知道**把flag字段改成0xFBAD1800**就行
