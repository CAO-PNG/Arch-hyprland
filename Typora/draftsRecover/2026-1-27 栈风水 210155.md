# 前言

栈风水----> 一切非常规的布局都是栈风水，我认为实际上是对于所有栈知识的灵活组合运用。所以重在灵活变通

这道题的栈风水在于利用任意地址写，实现任意次数的任意地址写，并且在程序使用start的时候会在栈上留下libc的地址，通过修改libc的地址，爆破使得地址泄漏；不过由于爆破需要非常多的时间，所以我会关闭地址随机化,并且我的脚本不会有爆破的步骤，因为非常费时间；

# 题: 

我们来说一下这个题吧

程序非常简单：只有一个main函数，并且仅仅溢出0x10的字节，，所以仅仅够覆盖返回地址，并且程序里面并没有给出任何后门函数

```assembly
.text:0000000000401288 ; int __fastcall main(int argc, const char **argv, const char **envp)
.text:0000000000401288                 public main
.text:0000000000401288 main            proc near               ; DATA XREF: _start+18↑o
.text:0000000000401288
.text:0000000000401288 buf             = byte ptr -8
.text:0000000000401288
.text:0000000000401288 ; __unwind {
.text:0000000000401288                 endbr64
.text:000000000040128C                 push    rbp
.text:000000000040128D                 push    rbx
.text:000000000040128E                 mov     rbp, rsp
.text:0000000000401291                 sub     rsp, 8
.text:0000000000401295                 mov     rdi, 0          ; fd
.text:000000000040129C                 lea     rsi, [rbp+buf]  ; buf
.text:00000000004012A0                 mov     rdx, 20h ; ' '  ; nbytes
.text:00000000004012A7                 call    _read
.text:00000000004012AC                 add     rsp, 8
.text:00000000004012B0                 pop     rbx
.text:00000000004012B1                 pop     rbp
.text:00000000004012B2                 retn
.text:00000000004012B2 main            endp
```

那么我们应该是可以注意到程序收栈的结构和我们正常的`leave ret`不太一样，这里的效果相当于`leave ret` ，但是不涉及到rbp， 也就是说rbp不影响栈。那么这里就有一个有意思的东西了，

看到这部分汇编：我们会发现从read读进去的地方是由rsi控制的 ，但是rsi又是由rbp寻址找到buf控制的 ，所以我们可以通过程序最后的`pop rbp`来控制下一次读进去的地方，这就是任意地址写

```assembly
.text:0000000000401295                 mov     rdi, 0          ; fd
.text:000000000040129C                 lea     rsi, [rbp+buf]  ; buf
.text:00000000004012A0                 mov     rdx, 20h ; ' '  ; nbytes
.text:00000000004012A7                 call    _read
```

而在前面我们又知道，`rsp`并不受`rbp`影响(因为正常的`rsp`是由`mov rsp,rbp`来控制的)，那么我们只需要将`rsp`放在一个满是`main`的或者`0x401295（read开始的地方）  `，这样我们就可以无限的读到任意地址了，并且以此循环！

无限次数的任意地址写成立，那么接下来就需要我们去想一下，我们需要泄漏`libc`，而程序是没有任何有关于控制寄存器的`gadget`

```bash
❯ ROPgadget --binary ./pwn --only "pop|ret"                                                                                                                                                     3.13.1  20:36
Gadgets information
============================================================
0x000000000040115d : pop rbp ; ret
0x00000000004012b0 : pop rbx ; pop rbp ; ret
0x000000000040101a : ret
0x00000000004012a2 : ret 0x20
0x0000000000401252 : ret 0x2be
0x000000000040105a : ret 0xffff

Unique gadgets found: 6
```

那么接下来我们就需要考虑一下我们的`_start`了，这个函数相信大家都不陌生，因为这个函数是程序真正的入口，

```assembly
.text:0000000000401090                 public _start
.text:0000000000401090 _start          proc near               ; DATA XREF: LOAD:00000000003FF018↑o
.text:0000000000401090 ; __unwind {
.text:0000000000401090                 endbr64
.text:0000000000401094                 xor     ebp, ebp
.text:0000000000401096                 mov     r9, rdx         ; rtld_fini
.text:0000000000401099                 pop     rsi             ; argc
.text:000000000040109A                 mov     rdx, rsp        ; ubp_av
.text:000000000040109D                 and     rsp, 0FFFFFFFFFFFFFFF0h
.text:00000000004010A1                 push    rax
.text:00000000004010A2                 push    rsp             ; stack_end
.text:00000000004010A3                 xor     r8d, r8d        ; fini
.text:00000000004010A6                 xor     ecx, ecx        ; init
.text:00000000004010A8                 mov     rdi, offset main ; main
.text:00000000004010AF                 call    cs:__libc_start_main_ptr
.text:00000000004010B5                 hlt
.text:00000000004010B5 ; } // starts at 401090
.text:00000000004010B5 _start          endp
```

可以看到调用了一个叫`__libc_start_main`的函数，这个函数会调用`__libc_start_call_main`，从而调用`main`函数，而在这个过程中，`__libc_start_main`也是需要保存返回地址的，也就是大家常见的用于收尾的函数，

![](./img/first-1.png)

而这个函数是`libc`的函数，所以，它的返回地址也是`libc`上的地址，